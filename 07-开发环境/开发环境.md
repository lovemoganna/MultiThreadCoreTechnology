## 开发环境

IDE,git(多人写作开发).JS模板化.打包工具.上线回滚的流程.

## git
```text
1.代码版本管理.
2.协作开发:合并.
3.git和Linux是一个作者.

coding.net/github.com
git服务器.git基本操作必须熟练.
```

### git常用你命令
```text
//添加所有修改的文件到暂存区
git add .

//还原文件,到上一个版本.
git checkout xxx 

//从暂存区往上提交
git commit -m "xxx"

//提交到远程仓库
git push origin master 

//下载别人提交的代码
git pull origin master

//查看分支
git branch

//新建一个分支,切换到已有的分支.
git checkout -b xxx /git checkout xxx
 
//从别的分支拷贝过来.
git merge xxx 

//查看文件状态
git status

```
### 初始化项目
```text
1.mkdir 与项目同名的文件夹
2.git init
3.echo "this is myproject JSQ-git's Readme.md 文件" > README.md
4.git add .   //将文件添加到暂存区
5.git commit -m "first add README.md"
6.git remote add origin https://git.coding.net/lovemoganna/JSQ-git.git
7.git push -u origin master (输入账号密码)

至此一次完整的提交代码过程完毕.
```
### 查看新增文件的不同
```text
比如说你修改了REEADME.md文件. 此时你可以使用 git status查看文件的状态.
可以使用 git diff + 文件名称 / git diff 来查看文件前后的不同之处.
```
![](https://upload-images.jianshu.io/upload_images/7505161-448bbcea48422cf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 撤销修改
```text
git checkout +文件名(但是一般都是不管用,因为你手快,执行了git add .)
```
### 查看分支
```text
1.查看分支
git branch
2.新建分支
git checkouot -b dev
3.添加到暂存区
git add.
4.提交信息
git commit -m "update part2"
5.远程推送到仓库上的Dev分支.
git push origin dev

6.如果推送不上去.先合并代码.再说.
git pull --rebase origin master
7.切换分支
git checkout master
8.从master拉取别人更新的代码
git pull origin master 
9.将dev分支的代码合并到master上面.
git merge dev
(删除分支: git branch -d branchname)
```

### 遇到棘手的问题
```text
git rebase –abort 放弃rebase，就是回到你执行git rebase那时的状态  
git rebase --skip 直接用远程分支的取代当前分支的 也就是覆盖了本地的代码  
```
```text
//合并代码的时候遇到以下的问题.

$ git merge dev
fatal: refusing to merge unrelated histories
//解决方法
$ git pull origin dev --allow-unrelated-histories

git push origin master

再一个就是git无法帮我们合并,存在冲突,需要我们自己手动解决.

一般就是重复的东西太多了,他没办法识别出来.

接下来,可以查看合并的过程.

git log --graph --pretty=oneline --abbrev-commit
```

### 常用日志

```text
git log --oneline
git log --p
```
### 版本回退
```text

1.本地分支版本回退:

git reset --hard +commitID
commitID通过 上面的日志可以查到.

2.自己的远程分支的回退
git reflog
git reset --hard commitID

强制推送到远程分支:
git push -f
注意:本地分支回滚后，版本将落后远程分支，必须使用强制推送覆盖远程分支，否则无法推送到远程分支
```

## 模块化ADM

### 不使用模块化的弊端

```text
util.js getFormatDate函数

a_util.js aGetFormatData函数,使用getFormatDate(针对业务)

a.js aGetFormatDate(依赖这个函数去用,业务代码)
``` 
![](https://upload-images.jianshu.io/upload_images/7505161-115c239646593fc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

他们之间的摆放顺序不能弄错,因为他们之间是一种强依赖的关系.

![](https://upload-images.jianshu.io/upload_images/7505161-5d03aeacbbe2069a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

所以就存在这2个问题:

1.全局边浪污染.

2.a.js不知道自己还需要依赖util.js.

![](https://upload-images.jianshu.io/upload_images/7505161-685db2c2a6ce8421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### AMD的介绍

`require.js`

它会全局define函数,全局require函数,依赖JS会自动,异步加载.
 
具体写法:

![](https://upload-images.jianshu.io/upload_images/7505161-4ea3332f6a26e93b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/7505161-5835cd08e6e28775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
 
 ### 实例操作
 ```text
主要是:

通过define来确定依赖关系,然后重新应用到新的业务场景里面去.

通过Require函数调用上一级的业务函数来定义出口函数main.js,最终通过data-main="./main.js"来时先函数的调用.

```

看一下require.js函数的CDN
```text
<script data-main="./main.js"  src="https://cdn.bootcss.com/require.js/2.3.5/require.min.js"></script>
```

他们之间的调用顺序:

![](https://upload-images.jianshu.io/upload_images/7505161-c2068ad6f97eb0ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


所谓异步加载就是说,你的业务场景发生了变化,也就是说可以更改业务的场景来进行灵活的调用.

## CommonJS

nodejs模块化规范,现在被大家大量使用.

前端开发依赖的插件和库,都可以从npm中获取.

构建工具的高度自动化,使得使用npm的成本非常低.

需要注意:

CommonJS不会异步加载JS,而是同步一次性加载出来.

### AMD和CommonJS的使用场景
```text
需要异步加载JS,就是用AMD.

使用了npm之后,就是用CommonJS.
```

 ## 构建工具
 很久之前grunt.
 
 之前使用gulp,现在使用webpack.
 
 先要安装一个服务器,静态使用的小型服务器:`node install http-server -g`,出错多重复几遍,就好了.
 
 可能有需要配置环境变量到Path.找到http-server文件夹的路径粘到环境变量的path下就可以了.
 
 安装webpack--- npm install webpack --save-dev (仅仅在生产环境依赖-dev)
 
 
 
 安装jquery--- npm install jquery --save  (开发运行都依赖)
 
 moment
 
 卸载 npm uninstall  moment --save
 
 
 ### webpack实例
 
 #### webpack配置文件 
 webpack.config.js
 ```text
var path = require('path')
var webpack = require('webpack')

module.exports = {
    // 定义src目录
    context: path.resolve(__dirname, './src'),
    entry: {
        //定义入口文件
        app: './app.js'
    },
    output: {
        //定义输出目录
        path: path.resolve(__dirname, './dist'),
        //定义输出文件
        filename: 'bundle.js'
    }
}
```
#### webpack在node中的配置

这点在node init,也就是初始化的时候自己可以设置.

其他库的安装,参考使用一下吧.

```text

```
```text
{
  "name": "webpack-test",
  "version": "1.0.0",
  "description": "webpack-test",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "webpack"
  },
  "author": "ligang",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^4.12.0",
    "webpack-cli": "^3.0.6"
  },
  "dependencies": {
    "jquery": "^3.3.1"
  }
}
```
#### 运行nodejs环境.
 ```text
找到package.json中的scripts部分:

添加
"start": "webpack"

启动:
npm start

有可能需要你安装webpack-cli

最后将
<script src="./dist/bundle.js"></script>
插入到HTML中

```
### jquery的使用(结合Commonjs)
a_util.js
```text
//输出一个对象.
module.exports = {
    print: function () {
        console.log(123);
    }
}
```
app.js
```text
// var $ = require("jquery")
//
// //获取DOM节点
// var $root = $(".root");
// //插入一段HTML
// $root.html('<p>hello node-jquery!</p>')


//Commonjs的使用.

var a_util=require("./a_utils")

a_util.print();
```
 
###  JS的压缩

```text
 webpack.optimize.UglifyJsPlugin has been removed, please use config.optimization.minimize instead.

也就是说之前的

plugins: {
    new webpack.optimize.UglifyJsPlugin();
}

被废弃了,现在自动给压缩.

```

## 上线回滚

### 知识点

1.上线和回滚的基本流程

2.Linux基本命令

#### 上线回滚流程

1.将测试完成的代码提交到git版本库的master分支.

2.将当前服务器的代码全部打包并记录版本号,备份.

3.将master分支的代码提交覆盖到线上服务器,生成新版本号.

#### 回滚流程

1.将当前服务器的代码打包并记录版本号,备份.

2.将备份的上一个版本号解压,覆盖到线上服务器,并生成新的版本号.

## Linux基本命令

测试服务器,可以自己使用.随便使用.

ssh name@server 登录

### 基本命令





