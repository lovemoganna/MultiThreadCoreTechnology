## 题目

```
1.JS中使用typeof能得到哪些类型?

2.何时使用===,何时使用==?

3.JS有哪些内置函数?

4.JS变量按照存储方式区分为哪些类型,并描述其特点.

5.如何理解JSON?
```

变量类型

值类型 & 引用类型

typeof运算符

## 值类型和引用类型
```js
//值类型
var a = 100;
var b = a;
a = 200;
console.log(b);//100
var c = b;
b  = 300;
console.log(c);
// 值类型改变新开辟一块内存空间.值类型赋值不会相互干预.
//引用类型

var a = {age: 20};
var b = a;
b.age = 200;
console.log(a.age);//200
var c = b;
c.age =25;
console.log(c);
console.log(b);
//先复制一个指针,但是2个指针指向的是同一个内存空间.也就是说引用类型共用一块内存空间.

// 引用类型包括对象,数组,函数
```

 **引用类型包括对象,数组,函数**
 ```text
a={"age":12}
{age: 12}
a.age
12
a.name
undefined
a.name="xiaoming"
"xiaoming"
a
{age: 12, name: "xiaoming"}
a.ccc=1212
1212
a
{age: 12, name: "xiaoming", ccc: 1212}

从上面可以看出.a作为一个引用  类型,是可以无限的添加属性的.
```

### 关于数组
```text
var arr =[1,2,3,4]
undefined
arr
(4) [1, 2, 3, 4]
var arr2 =arr;
undefined
arr2
(4) [1, 2, 3, 4]
arr2.age=22
22
arr2
(4) [1, 2, 3, 4, age: 22]
arr2.name ="王小明"
"王小明"
arr2
(4) [1, 2, 3, 4, age: 22, name: "王小明"]
```
```text
var arr=[1, 2, 3, 4, {age: 22, name: "王小明"}];
console.log(arr.length);//5
```
### 关于函数
```text
function f1(){}
undefined
f1
ƒ f1(){}
f1.age=12;
12
f1
ƒ f1(){}
f1.age
12
var f2 = f1;
undefined
f2.age
12
f2.age = 22;
22
f1.age
22
```

所以不光对象可以使用引用类型,数组和函数都可以用属性.

## typeof
记住这个:
```text
typeof NaN
"number"

typeof 123
"number"

typeof "123"
"string"

typeof undefined
"undefined"

typeof true
"boolean"
//以上是4个值类型,均可以被typeof识别.

typeof null
"object"﻿

function fn(){}
undefined
typeof(fn)
"function"
```
typeof只能区分值类型的相应类型:number,string,boolean,undefined.

像null,函数,数组,对象结果都是object.

也就是说typeof只能区分值类型,并不能区分引用类型.

## 强制类型转换
 ```text
100 + '1]'
"1001]"

100 == '100'
true

'' == 0
true

100 === '100'
false

'' === 0
false

null == undefined
true

null === undefined
false
```
从上面可以看出,三个等号并不会进行强制类型转换,而两个等号会.

### 关于if的强制类型转换
```text
if(100){console.log("hi")}
VM976:1 hi

if(true){console.log("hii")}
VM983:1 hii

if(''){console.log("hiii")}// '' 默认为false
undefined

if(NaN){console.log("hiii")} // NaN默认为false
undefined
```
**0,NaN,'',null,undefined,false.**在if里面是false.

### 关于逻辑运算
与 或 非
```text
10 && 0
0

'' || 'abc'
"abc"

var a =100;
!!a
true

var a = ''
undefined
!!a
false

var a = NaN
undefined
!!a
false

!!1
true

!!'a'
true

!!''
false
```
### 内置函数
```text
Object 
ƒ Object() { [native code] }
Array
ƒ Array() { [native code] }
Function 
ƒ Function() { [native code] }
```

### 内置对象
```text
Math
Math {abs: ƒ, acos: ƒ, acosh: ƒ, asin: ƒ, asinh: ƒ, …}
JSON
JSON {parse: ƒ, stringify: ƒ, Symbol(Symbol.toStringTag): "JSON"} 
```
### ==的使用
1.判断属性存不存在

2.判断函数的参数存不存在
```text
var obj = {}
undefined
if(obj.a == null){}
undefined
function(a,b){if(a ==null){console.log("hi");}}
```
## 原型和原型链

### 题目
```text
1.如何准确判断一个变量是数组类型.
2.写一个原型链继承的例子.
3.描述new一个对象的过程.
4.zepto(或其他框架)源码中如何使用原型链.
```
### 知识点
```text
构造函数
构造函数 - 扩展
原型规则和示例
原型链
instanceof
```            

### 构造函数

****见到大写字母开头的函数基本上就是构造函数.

```text
// 构造函数名称首字母一定要大写
function Foo(name, age) {
    this.name = name;
    this.age = age;
    this.class = 'class-1';
    //return this;//默认是有这一行的.
}

var p = new Foo("小明", 12);
// new函数执行的时候,this先变为一个空对象,然后进行this.xxx赋值,最终默认把this再return回来.此时p就具备了p.name p.age的特性.
var p2 = new Foo("小红", 13);
console.log(p);
console.log(p2);
```

### 构造函数-扩展
```text
var a ={}  ---其实是var a = new Object() 的语法糖.
var a =[]  ---其实是var a = new Array() 的语法糖.

function Foo(){...} ---其实是var Foo = new Function(){...}
```
**使用instanceof判断一个函数是否是一个变量的构造函数.**

 比如判断一个变量是否为数组:
 
 变量 instanceof Array.
 
 ```text
[12,31,121] instanceof Array
true
```
### 原型规则和示例

5条原型规则
原型规则是学习原型链的基础.
#### 第一条
>所有的引用类型(数组,对象,函数),都具有对象特性,即可自动扩展属性(null用typeof得出的结果尽管是Object,但是不能自由扩展.)

示例:;
```text
var obj = {}; obj.a =100;
100
var arr = []; arr.a =100;
100
function fn(){};fn.a=100;
100
obj
{a: 100}
arr
[a: 100]
fn
ƒ fn(){}
```

#### 第二条
>所有的引用类型(数组,对象函数),都有一个__proto__属性,属性值是一个普通对象.这些都是浏览器帮助我们做的事.

__proto__是一个隐式原型属性.

示例:
```text
console.log(obj.__proto__);

VM1657:1 {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}

console.log(arr.__proto__);

VM1658:1 [constructor: ƒ, concat: ƒ, pop: ƒ, push: ƒ, shift: ƒ, …]concat: ƒ concat()constructor: ƒ Array()copyWithin: ƒ copyWithin()entries: ƒ entries()every: ƒ every()fill: ƒ fill()filter: ƒ filter()find: ƒ find()findIndex: ƒ findIndex()forEach: ƒ forEach()includes: ƒ includes()indexOf: ƒ indexOf()join: ƒ join()keys: ƒ keys()lastIndexOf: ƒ lastIndexOf()length: 0map: ƒ map()pop: ƒ pop()push: ƒ push()reduce: ƒ reduce()reduceRight: ƒ reduceRight()reverse: ƒ reverse()shift: ƒ shift()slice: ƒ slice()some: ƒ some()sort: ƒ sort()splice: ƒ splice()toLocaleString: ƒ toLocaleString()toString: ƒ toString()unshift: ƒ unshift()Symbol(Symbol.iterator): ƒ values()Symbol(Symbol.unscopables): {copyWithin: true, entries: true, fill: true, find: true, findIndex: true, …}__proto__: Object

console.log(fn.__proto__);

VM1662:1 ƒ () { [native code] }
```
#### 第三条
>所有的**函数**,都有一个prototype属性,属性值是一个普通的对象.

千万记住,是只针对函数.!!!

prototype是一个显式原型的属性.但这是浏览器帮助我们做的事.

示例:
```text
console.log(fn.prototype)
VM1709:1 {constructor: ƒ}
```

#### 第四条
>所有的引用类型(函数,数组,对象),__proto__属性值指向它的构造函数的"prototype"的属性值.

示例:我们用完全等于.
```text
console.log(obj.__proto__ === Object.prototype)
VM1757:1 true
```

var obj ={} 等价于 var obj = new Object();

**所以obj的构造函数就是Object.**

Object是一个函数,也可以拥有显示原型的属性prototype.

#### 前四条的总结

```text
1.所有的引用类型都可以扩展属性.
2.所有的引用类型都有隐式原型属性- __proto__
3.所有的函数都有显式原型属性- prototype
4.所有的引用类型都有隐式原型的属性,都会指向它的构造函数的显式原型属性.

比如: var obj = {}  等价于 var obj = new Object();
我们可以看出Object就是obj的构造函数.
根据第四条就得出:
obj._proto__ === Object.prototype的结论.注意这里是严格的比较.
```
#### 第五条
>当试图得到一个引用类型的某个属性时,如果这个引用类型本身没有这个属性,那么就会去它的__proto__中寻找.(也就是跑到它的构造函数的prototype中去寻找.)

console.log(obj._proto__ === Object.prototype);
示例:

```text
function Doo(name,age){this.name = name;this.age =age;}
undefined
Doo.prot
undefined
console.log(Doo.prototype);
VM1920:1 
{constructor: ƒ}
constructor
:
ƒ Doo(name,age)
__proto__
:
Object
```

具体实例:

```text
//构造函数
function Foo(name, age) {
    this.name  =name;
}

//每个构造函数都有显式原型,显式原型是一个__proto__对象.
// 那么Foo.prototype也就是指向了Foo的显式原型,显式原型是一个__proto__对象.完全可以对这个对象进行扩展属性alterName.

Foo.prototype.alterName = function () {
    console.log(this.name);
};

var f = new Foo("zhangsan");
f.printName = function () {
    console.log(this.name);
}
// f是一个对象,现在f只有一个name属性.
f.printName();//zhangsan

// f的构造函数是Foo函数,也就是f的隐式原型指向Foo的显式原型.
//
// f本身并没有alterName的属性.只有printName的属性.
//     但是他会去f的隐式原型目录中去寻找.f的隐式原型执行的就是它的构造函数Foo的显式原型.
//     Foo的显示原型已经被扩展了一个属性.所以会执行到了Foo.prototype.alterName.
f.alterName();//张三
```

### this

```text
//构造函数
function Foo(name, age) {
    this.name  =name;
}
Foo.prototype.alterName = function () {
    console.log(this.name);
};
var f = new Foo("zhangsan");
f.printName = function () {
    console.log(this.name);
}
f.printName();//zhangsan
f.alterName();//张三

里面的this就是f.
```
只要我们通过对象的属性去执行函数.

**无论函数是自身的属性还是从它的原型中得到的一个属性,
它的函数执行的this永远是指向f(对象)本身.**

如果遍历上面的f,我们至少能拿到3个属性:name,printName.alterName.

#### 循环自身的属性
```text
var item

for(item in f){
    //高级浏览器已经在for in 中屏蔽了来自原型的属性.
    //但是这里建议我们加上这判断,保证程序的健壮性.
    //这里我们只希望拿到f本身的属性
    if(f.hasOwnProperty(item)){
        console.log(item)
    }
}
```

### 原型链
![](https://upload-images.jianshu.io/upload_images/7505161-1904450a2a6e02e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```text
Foo-构造函数
F-对象
Foo.prototype -显式原型对象
Object.prototype -显式原型对象
Object-Foo的构造函数

Foo这个构造函数本身有一个Foo.prototype显式原型对象.

f是new出来的一个对象,他的隐式原型对象__proto__指向Foo.prototype这个显式原型对象.

但是Foo.prototype本身也是一个对象,他的隐式原型__proto__指向他的构造函数Object的显式原型Object.prototype.

```
为了避免死循环,**构造函数Object的隐式原型__proto__对象即为null.**


### instanceof的用法

**instanceof是判断引用类型属于哪个构造函数的.**

比如拿上面的例子来进行判断.

`f instanceof Foo`的判断逻辑是:

f的__proto__一层一层往上,是否可以对应到Foo.prototype.

`Foo instance Object`的判断逻辑是:

Foo的__proto__一层层往上,是否可以对应到Object的prototype.

### 题目

1.如何准确判断一个变量是数组类型?
```text
var arr =[]
arr instanceof Array //true
typeof arr //Object ,typeof是无法判断是否是数组的.
typeof null //Object ,typeof是无法判断是否是数组的.
typeof NaN //number
```
2.写一个原型链继承的例子.
```text
// 封装一个DOM查询的示例.
//定义一个函数Elem.并定义一个通过id来获得元素的方法.
function Elem(id){
    this.elem = document.getElementById(id);
}
    // 给此构造函数添加一个替换HTML的方法
    Elem.prototype.html = function (val) {
    //先获得此元素
        var elem = this.elem;
        if (val){
            //插入新的HTML
            elem.innerHTML = val;
            //链式操作的关键.
            return this;
        }
        else {
            //返回原来的HTML内容.
            return elem.innerHTML;
        }
    };

    //再给元素扩展一个事件绑定的方法(事件类型,回调函数)
    Elem.prototype.on =function (type,fn) {
        //获得此元素
        var elem = this.elem;
        //绑定事件
        elem.addEventListener(type,fn);
        return this;//链式操作的关键在于此.
    };

    //获取此节点的所有HTML
    var div1 = new Elem("Main-Article-QQ");
    console.log(div1.html());

    //替换文本!
    // div1.html("<p>hello world</p>");
    // div1.on("keyup",function () {
    //     alert("_keyup!")
    // })
    //链式操作
    div.html("<a href='123'>小明</a>").on("click",function () {
        console.log("xiaoming").html("<p>小红</p>");
    });
```

3.描述new一个对象的过程.
```text
1.创建一个新对象,
2.this指向这个新对象,
3.执行代码,就是对this赋值
4.返回this.

function Foo(name,age){
    this.name = name;
    this.age = age;
    this.class = "class-1";
    //return this;
}
var f =new Foo("zhangsan",20);
```

4.zepto(或其他框架)源码中如何使用原型链.
```text
阅读源码是提高技能的方式.
搜索资料.
jquery源码分析.
zepto设计和源码分析.
```
### 原型链示例-封装DOM操作的演示:

```js
function Elem(id){
    this.elem = document.getElementById(id);
}
    // 给此构造函数添加一个替换HTML的方法
    Elem.prototype.html = function (val) {
        var elem = this.elem;
        if (val){
            //插入新的HTML
            elem.innerHTML = val;
            //链式操作的关键.
            return this;
        }
        else {
            //返回原来的HTML内容.
            return elem.innerHTML;
        }
    };

    //再给元素扩展一个事件绑定的方法(事件类型,回调函数)
    Elem.prototype.on =function (type,fn) {
        var elem = this.elem;
        //绑定事件
        elem.addEventListener(type,fn);
        return this;//链式操作的关键在于此.
    };

    //获取此节点的所有HTML
    var div1 = new Elem("Main-Article-QQ");
    //console.log(div1.html());

    //链式操作
    div1.html("<a href='123'>小明</a>").on("click",function () {
        alert("success!")
    });
```
![](https://upload-images.jianshu.io/upload_images/7505161-138584568ed615a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 代码演示
在构造方法中,最好不要使用return.
![](https://upload-images.jianshu.io/upload_images/7505161-3cd63e446e3d1b25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 定义一个构造函数+new一个对象
![](https://upload-images.jianshu.io/upload_images/7505161-88f38626283ea064.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

new一个对象的过程.

>先是生成一个实例,然后去调用构造函数中this中的方法,然后赋值,然后将this返回.f就具备了这些属性.

#### instanceof的比较
```text
var a = []

var b ={}

a instanceof Array
true

b instanceof Object
true

function fn(){}//特别注意函数的比较是大写的Function.
fn instanceof Function
true

还需要记住一些语法糖

var arr =[] 等价于 var arr = new Array();
var obj ={} 等价于 var obj = new Object();
function fn(){}; 等价于 fn = new Function(...);

不用记住.
```

#### 5点原型的规则
```
1.引用类型可以随意的扩展属性.
2.任意引用类型都有隐式原型属性.
3.所有的函数都有显式原型属性.
4.所有的引用类型的隐式原型属性都会指向它的构造函数的显式原型属性.

obj.__proto__ == Object.prototype
true
5.查找一个对象的属性,会去它的隐式原型中查找,如果查找不到,就会去它的构造函数的显示原型中去查找. 
```


![](https://upload-images.jianshu.io/upload_images/7505161-1a4ccf63fb2e6e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/7505161-53229c0421935aae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](https://upload-images.jianshu.io/upload_images/7505161-34ce3edd43dc4ba3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可以看出二者相同:

![](https://upload-images.jianshu.io/upload_images/7505161-386047e5d2d51536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### 原型链

![](https://upload-images.jianshu.io/upload_images/7505161-f1f3aecc2fdb03f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


查这个位置的方法就去查f.__proto__,也就查到了f的构造函数Foo.prototype.

接着Foo.prototype本身也是一个对象,他也有自己的隐式原型对象.

会去他的构造函数Object去查Object.prototype.

结果自然是null.

也就相当于`f.__proto__.__proto__`这样的方式查找.

![](https://upload-images.jianshu.io/upload_images/7505161-6e7d99a722487179.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#### instanceof

各种引用类型(数组,对象,函数),特别记住

function fn(){};
fn instanceof function  //结果是Function. 

